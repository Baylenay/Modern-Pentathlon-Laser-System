# import the necessary packages
from picamera.array import PiRGBArray
from picamera import PiCamera
import time
import math
import cv2
import numpy as np
import RPi.GPIO as GPIO
import socket
import os
import subprocess

#UDP setup
UDP_PORT_iPad = 2391
UDP_PORT_Pi = 2390
UDP_IP_iPad = "192.168.0.12"
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind(("", UDP_PORT_Pi))
sock.setblocking(0)

# Initialising leds 1-5 as outputs

GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# LED 1
GPIO.setup(17, GPIO.OUT)
GPIO.setup(18, GPIO.OUT)
# LED 2
GPIO.setup(22, GPIO.OUT)
GPIO.setup(23, GPIO.OUT)
# LED 3
GPIO.setup(6, GPIO.OUT)
GPIO.setup(12, GPIO.OUT)
# LED 4
GPIO.setup(19, GPIO.OUT)
GPIO.setup(16, GPIO.OUT)
# LED 5
GPIO.setup(26, GPIO.OUT)
GPIO.setup(20, GPIO.OUT)

# Defining functions

def LED(pin, state):
    if pin == 1:
        a = 17
        b = 18
    if pin == 2:
        a = 22
        b = 23
    if pin == 3:
        a = 6
        b = 12
    if pin == 4:
        a = 19
        b = 16
    if pin == 5:
        a = 26
        b = 20
    if state == 0:      # 0th state makes led red
        LED_ON(a, b)
    if state == 1:      # 1st state makes led green
        LED_ON(b, a)
    if state == 2:      # 2nd state turns led off
        LED_OFF(a, b)

def LED_ON(pin1, pin2):
    GPIO.output(pin1, GPIO.HIGH)
    GPIO.output(pin2, GPIO.LOW)

def LED_OFF(pin1, pin2):
    GPIO.output(pin1, GPIO.LOW)
    GPIO.output(pin2, GPIO.LOW)

def Update_LEDS(G_LEDS):
    G_LEDS += 1
    for i in range (1, G_LEDS+1):
        LED(i, 1)
        if i == 5:
            G_LEDS = LED_Start_Sequence(G_LEDS)
    return G_LEDS

def LED_Start_Sequence(GR_LEDS):
    for i in range (1, 6):
        LED(i, 2)
    for i in range (1, 6):
        LED(i, 1)
        time.sleep(0.5)
        LED(i, 0)
    GR_LEDS = 0
    return GR_LEDS

def flash_LED(Green_LEDS, flashing_off):
    if flashing_off == True:    #Turn on LEDs
        for i in range (1, Green_LEDS+1):
            LED(i, 1)
        for i in range (Green_LEDS+1, 6):
            LED(i, 0)
        flashing_off = False
    else:                       #Turn off LEDs
        for i in range(1, 6):
            LED(i, 2)
        flashing_off = True

    return flashing_off

def get_corners_from_contours(contours, corner_amount=4):
    """
    Finds four corners from a list of points on the goal
    epsilon - the minimum side length of the polygon generated by the corners

    Parameters:
        :param: `contours` - a numpy array of points (opencv contour) of the
                             points to get corners from
        :param: `corner_amount` - the number of corners to find
    """
    hull_temp = []
    coefficient = .05
    while True:
        # print(contours)
        epsilon = coefficient * cv2.arcLength(contours, True)
        # epsilon =
        # print("epsilon:", epsilon)
        poly_approx = cv2.approxPolyDP(contours, epsilon, True)
        hull = cv2.convexHull(poly_approx)
        if len(hull) == corner_amount:
            hull_temp.append(hull[2])
            hull_temp.append(hull[3])
            hull_temp.append(hull[1])
            hull_temp.append(hull[0])
            return hull_temp
        else:
            if len(hull) > corner_amount:
                coefficient += .01
            else:
                coefficient -= .01

def Score(cx, cy, x, y):
    X = k*(x - cx)
    Y =  k*(cy - y)
    dst = math.sqrt(X**2 + Y**2)
    score = int(10-(dst/ring_width))
    print(dst)
    if dst < target_inner_radius_dot:
        hit = True
    else:
        hit = False

    coord = [X, Y, score, int(hit)]
    return coord

def save_image():
    print('Uploading...')
    path = '/home/pi/TargetImages'
    # first upload contents of TargetImages directory
    fullDirectory = path
    command = '/home/pi/Dropbox-Uploader/dropbox_uploader.sh upload ' + fullDirectory + ' /TargetFiles/'
    os.system(command)
    # then clear contents of TargetImages directory
    fileList = os.listdir(path)
    for fileName in fileList:
        os.remove(path + '/' + fileName)
    print('Directory cleared')
    # then save target with all shots ever
    cv2.imwrite('TargetAllShots.jpg', imgAllShots)
    fullDirectoryAll = '/home/pi/TargetAllShots.jpg'
    commandAll = '/home/pi/Dropbox-Uploader/dropbox_uploader.sh upload ' + fullDirectoryAll + ' /TargetFiles/'
    os.system(commandAll)
    print('Finished uploading')

def decodeMsg(data):

    code = 0
    reset = "reset"
    reset = reset.encode()

    calibrate = "calibrate"
    calibrate = calibrate.encode()

    flash = "flash"
    flash = flash.encode()

    save = "saveToDropbox"
    save = save.encode()

    flash = "Flash"
    flash = flash.encode()

    stop = "stop"
    stop = stop.encode()

    if data == reset:
        code = 1
        print('reset')
    if data == calibrate:
        code = 2
        print('calibrate')
    if data == save:
        code = 3
        print('saving to dropbox')
    if data == flash:
        code = 4
        print('flashing')

    if data == stop:
        code = 5
        print('stopping')

    return code


# initialize the camera and grab a reference to the raw camera capture
camera = PiCamera()
camera.resolution = (640, 480)
camera.framerate = 30
rawCapture = PiRGBArray(camera, size=(640, 480))
##camera.brightness = 70
##camera.contrast = 10
##camera.saturation = 99
target_side = 170
target_side_pxl = 600
k = target_side/target_side_pxl
target_inner_radius = 31.2
ring_width = 7.8
K = 657/(20*ring_width)
dot_radius = 3
target_inner_radius_dot = target_inner_radius + dot_radius
Green_LEDS = 0
loop_time = 0
loop_count = 0
corners_found = False
centre_found = False
img = cv2.imread('TargetFresh.jpg', 1)
imgAllShots = cv2.imread('TargetAllShots.jpg', 1)
hits = 0
path = '/home/pi/TargetImages'
flashing_off = False



# allow the camera to warmup while testing LEDs are working
Green_LEDS = LED_Start_Sequence(Green_LEDS)

# capture frames from the camera
for frame in camera.capture_continuous(rawCapture, format="bgr", use_video_port=True):

    start_time = time.time()

    img_original = frame.array #current frame

    #Check for corners
    if corners_found == False:

        #Threshold image to find corners and centre of target
        img_gray = cv2.cvtColor(img_original, cv2.COLOR_BGR2GRAY)
        _, target_thresh = cv2.threshold(img_gray, 110, 255, cv2.THRESH_BINARY)
        _, target_contours, _ = cv2.findContours(target_thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)

        for contour in target_contours:
            area = cv2.contourArea(contour)
            #print(area)
            if 135000 < area < 145000:

                corners = np.float32(get_corners_from_contours(contour, 4))

                corner_0 = corners[0]
                corner_1 = corners[1]
                corner_2 = corners[2]
                corner_3 = corners[3]

                corner_00 = corner_0[0]
                corner_01 = corner_1[0]
                corner_02 = corner_2[0]
                corner_03 = corner_3[0]

                corner_000 = int(corner_00[0])
                corner_001 = int(corner_00[1])

                corner_010 = int(corner_01[0])
                corner_011 = int(corner_01[1])

                corner_020 = int(corner_02[0])
                corner_021 = int(corner_02[1])

                corner_030 = int(corner_03[0])
                corner_031 = int(corner_03[1])

                target_corners = np.float32([[0, 0], [target_side_pxl, 0], [0, target_side_pxl], [target_side_pxl, target_side_pxl]])

                corners_found = True
                print('corners found')
                print ("Corners: " + str(corners))

                old_image = img_original

    #Check for centre
    if (corners_found == True) and (centre_found == False):

        #Perspective transform target and threshold to find centre of target
        matrix = cv2.getPerspectiveTransform(corners, target_corners)
        img_transform = cv2.warpPerspective(img_original, matrix, (target_side_pxl, target_side_pxl))
        img_transform_gray = cv2.cvtColor(img_transform, cv2.COLOR_BGR2GRAY)


        _, inner_rad_thresh = cv2.threshold(img_transform_gray, 80, 255, cv2.THRESH_BINARY_INV)
        _, inner_rad_contours, _ = cv2.findContours(inner_rad_thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)

        for contour in inner_rad_contours:
            area = cv2.contourArea(contour)
            #print (area)
            if 30000 < area < 37000:
                cv2.drawContours(img_transform_gray, contour, -1, (0, 255, 0), 3)
                M =cv2.moments(contour)
                cX = int(M["m10"] / M["m00"])
                cY = int(M["m01"] / M["m00"])
                cv2.circle(inner_rad_thresh, (cX, cY), 4, (0, 255, 0), -1)
                centre_found = True
                print('centre found')
                #Once corners and centre have been found send message to iPad
                calibrated = "calibrated"
                calibrated = calibrated.encode()
                sock.sendto(calibrated, (UDP_IP_iPad, UDP_PORT_iPad))

    #Check for laser dot
    if (corners_found == True) and (centre_found == True):

        #cv2.circle(img_original, (corner_000, corner_001), 4, (0, 0, 255), -1)#red
        #cv2.circle(img_original, (corner_010, corner_011), 4, (0, 255, 0), -1)#green
        #cv2.circle(img_original, (corner_020, corner_021), 4, (255, 0, 0), -1)#blue
        #cv2.circle(img_original, (corner_030, corner_031), 4, (0, 0, 0), -1)#black

        img_original_green = img_original[:,:,1]    #Look at only green pixels of current image
        old_image_green = old_image[:,:,1]          #Look at only green pixels of old image

        #Subtract old from current and then threshold before summing pixels
        img_laser = cv2.subtract(img_original_green, old_image_green)
        _, laser_img_thresh = cv2.threshold(img_laser, 25, 255, cv2.THRESH_BINARY)
        img_laser_error = np.sum(laser_img_thresh)

        #If result of summing pixels is >10 then possible laser spots
        if img_laser_error > 10: # this means that a dot may have been found (could be noise)
            print('Potential laser spot')

            #Perspective transform thresholded image and threshold to find laser dot
            img_transform_laser = cv2.warpPerspective(laser_img_thresh, matrix, (target_side_pxl, target_side_pxl))
            _, laser_thresh = cv2.threshold(img_transform_laser,25, 255, cv2.THRESH_BINARY)
            _, laser_contours, _ = cv2.findContours(laser_thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)

            cv2.imshow("Laser thresh", laser_thresh) #can be removed

            #Set count variables for dot CofMs to zero
            X_dot_tot = 0
            Y_dot_tot = 0
            i = 0

            for contour in laser_contours:
                #area = cv2.contourArea(contour)
                #print (area)
                M = cv2.moments(contour)
                if M["m00"] != 0:
                    X_dot = int(M["m10"] / M["m00"])
                    Y_dot = int(M["m01"] / M["m00"])
                    X_dot_tot += X_dot
                    Y_dot_tot += Y_dot
                    i += 1
                    cv2.circle(img_transform, (X_dot, Y_dot), 3, (255, 255, 0), -1)

            #If there were any contours:
            if i != 0:
                #Find average of CofMs
                X_dot_avg = int(X_dot_tot/i)
                Y_dot_avg = int(Y_dot_tot/i)
                cv2.circle(img_transform, (X_dot_avg, Y_dot_avg), 6, (255, 0, 0), -1) #can be removed
                shot_info = Score(cX, cY, X_dot_avg, Y_dot_avg)
                XCoord = shot_info[0]
                YCoord = shot_info[1]
                #Display shot information - can be removed
                print('Coordinates: ' + str(shot_info[0]) + ', ' + str(shot_info[1]))
                print('Score: ' + str(shot_info[2]))
                print('Hit: ' + str(shot_info[3]))
                #Scaled to find x and y coordinates referring to the pixels on the target image
                x = int(350 + K*XCoord)
                y = int(352 - K*YCoord)

                #Send shot info to iPad
                Packet = "shot:" + str(x) + ":" + str(y) + ":" + str(shot_info[2]) + ":" + str(shot_info[3])
                Packet = Packet.encode()
                print(Packet)
                sock.sendto(Packet, (UDP_IP_iPad, UDP_PORT_iPad))

                if shot_info[3] == True:
                    hits += 1
                    #Update target images with shot (green)
                    cv2.circle(img, (x, y), 10, (0, 255, 0), -1)
                    cv2.circle(imgAllShots, (x, y), 10, (0, 255, 0), -1)

                    if hits == 5:
                        #When the centre hit 5 times reset hit count and save image to pi directory
                        hits = 0
                        dateString = time.strftime("%H_%M_%S-%d_%m_%Y")
                        filename = str(path + '/Target' + dateString + '.jpg')
                        cv2.imwrite(filename, img)
                        #refresh target image
                        img = cv2.imread('TargetFresh.jpg', 1)
                    Green_LEDS = Update_LEDS(Green_LEDS)
                else:
                    #Update target images with shot (red)
                    cv2.circle(img, (x, y), 10, (0, 0, 255), -1)
                    cv2.circle(imgAllShots, (x, y), 10, (0, 0, 255), -1)

        cv2.imshow("Laser target", img_transform)

    #Check buffer for any packets
    while True:
        try:
            data, addr = sock.recvfrom(1024)
            print(data)
            #Determine the message and give it a code
            code = decodeMsg(data)
            #Check code to see what to do next
            if (code == 1):
                #Resets the system
                Green_LEDS = LED_Start_Sequence(5)  # Sets Green_LEDS = 0
                hits = 0
                break
            #Calibrates:
            if (code == 2):
                corners_found = False
                centre_found = False
                break
            #Saves to Dropbox
            if (code == 3):
                save_image()
                saved = "saved"
                #Relay the message that the image has been saved
                saved = saved.encode()
                sock.sendto(saved, (UDP_IP_iPad, UDP_PORT_iPad))
                break

            if (code == 4):
                flashing_off = flash_LED(Green_LEDS, flashing_off)
                break
            #Stop as 50 seconds are up
            if (code == 5):
                Green_LEDS = LED_Start_Sequence(5)
                hits = 0
                #Save target image
                dateString = time.strftime("%H_%M_%S-%d_%m_%Y")
                filename = str(path + '/Target' + dateString + '.jpg')
                cv2.imwrite(filename, img)
                #Refresh target image
                img = cv2.imread('TargetFresh.jpg', 1)
        except:
            break


    #make current frame old frame in preperation for next loop
    old_image = img_original

    #Test time for each loop to make sure it does not exceed 15.6ms
    end_time = time.time()
    loop_time += end_time - start_time
    loop_count += 1
    if(loop_count > 10):
        avg_time = loop_time/loop_count
        #print(avg_time)
        loop_time = 0
        loop_count = 0


    # show the frame
    cv2.imshow("Frame", img_original)
    cv2.imshow("target_thresh", target_thresh)


    key = cv2.waitKey(1) & 0xFF

    # clear the stream in preparation for the next frame
    rawCapture.truncate(0)

    # if the `q` key was pressed, break from the loop
    if key == ord("q"):
            break
